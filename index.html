<!doctype html>
<html lang="en">

<head>
  </head>

  <body>
<div style="text-align:center">
<h2>Delauney Triangulations by Iskender Akhemedov and Connie Zhou</h2>
<!--<h3>By Iskender Akhemedov and Connie Zhou</h3>-->
</div>
<div id="observablehq-96a9ef30"></div>
<div style="text-align:center">
<!--<button  onClick="window.location.reload()";>New Graph</button>-->
</div>

<div>
<h4>The Problem</h4>
<p>Create edges between a set of points such that any “network” distance between two points is only a factor of Euclidean distance of two points.
Given a set of n points, construct a graph such that for any point Vi and Vj, the detour ratio
t = d(G)(Vi, Vj)/d(E)(Vi, Vj) is a small constant.</p>

<h4>Trivial solution</h4>
<p>If we create a complete graph G connecting every point, we get a ratio t that is constant since all edges will have edges to each other. However this is expensive to store and maintain as we will have O(v2) edges.
</p>

<h3>So how can we create a subset of complete graph G such that the number of edges = O(V) and t = low constant? Enter Delaunay triangulations!
</h3>

<h4>Definition</h4>
<p>A Delaunay Triangulation is a special type of triangulation where a circumcircle drawn around any 3 points forming a triangle inside of G do not contain any vertices of G inside. As a result, the Delaunay triangulation maximizes the smallest angle of G.

While there are numerous possible triangulations for any graph, a Delaunay triangulation is unique for every point set, assuming general position - that is no 4 points are on the same circle.

</p>
<p>Unique attributes: maximizes the smallest angle - creates a “nice” looking graph</br>
</br>
Delaunay triangles are known as “well-shaped” due to fulfilling the empty circumcircle property - the ability to form a circumcircle with any triangle and having no vertices within that circle.
There exists a degenerate case when 4 (or more) points exist on the same circumcircle, generating many possible Delaunay triangulations for the same set of points. These degenerate cases will be ignored in further study of Delaunay in this project.
</br>
</br>
Delaunay can be extended to further dimensions. For example, a triangulation in 3D produces a tetrahedron which satisfies the empty circumsphere criterion instead. There are 3 steps to creating a Voronoi from an existing Delaunay triangulation:
</br>
</br>
Compute the perpendicular bisectors from each of a Delaunay triangulation - these will form the edges of a Voronoi diagram
Find the intersection of 3 perpendicular bisectors within each Delaunay triangle - this will form a vertex of a Voronoi diagram.
Ensure every perpendicular bisector doesn’t extend past the intersection within each triangle - to form clear regions within a Voronoi [Stack Overflow]
</br>
</br>
<img src="./example/v1.png" width="350" height="350">
<img src="./example/v2-5.png"  width="350" height="350">
<img src="./example/v3.png" width="350" height="350">
<img src="./example/v4.png"  width="350" height="350">
</br>
</br>
Et voila! These bisectors form a polyhedron around every vertex on the original Delaunay triangle. The most useful aspect of a Voronoi is that every region has the closest Euclidian distance to the original vertex on the Delaunay triangulation.


</P>

<h4>Algorithm</h4>
<p>
The algorithm defined hereafter is a divide and conquer type algorithm created by Guibas and Stolfi. </br>

The algorithm has three major parts: </br></br>

Ordering every point based on x-coordinate </br>
Dividing points until a base case of 2-3 points is reached </br>
Merging local Delaunay triangulations until all sub-graphs have been merged </br></br>

The first part is a trivial sort, which can be done in O(nlogn) time.</br>
The second part divides the point sets into 2 groups and recurses on each part, until every group is size 2-3. Creating a Delaunay triangulation of 2 or 3 points is trivial - 2 points always form an edge and 3 points always form a triangle (except for a degenerate case of 3 points forming a line which will be ignored). At this step we can also find a min of each subset and store it locally - this can be done in constant time for every base case.</br>
z<img src="./example/1.png" width="500" height="500">
<img src="./example/2.png"  width="500" height="500">
</br>
The third step is perhaps most complicated. Zipping two Delaunay triangulations together often involves removing some edges and always involves adding new edges.</br></br>

</p>
<p style="line-height:25px">
The following is a description of a merge of two Delaunay triangulations, G1 and G2, into G3:</br></br>

1. Using G1 and G2, we create a base edge E that will definitely be on the merged G3 (G2+G1), we find this base edge by finding the lowest or highest edge between the two groups. <br>
<img src="./example/b1.png" width="300" height="300">
<img src="./example/b2.png" width="300" height="300">
<img src="./example/b3.png" width="300" height="300">
<img src="./example/b4.png" width="300" height="300">
<img src="./example/3.png" width="300" height="300">
</br>
2. We then examine G1 for a potential candidate vertex L that might be connected to the base edge from the G1 side. We do this by stepping through vertices connected to the base edge, let’s call them set X, and forming circumcircles the two vertices on the base edge, and every point on set X. We step through X in order of increasing angle, starting with vertex that forms the smallest angle with the base edge When we encounter a circumcircle that does not contain any vertices on the inside, that vertex within set X becomes L.</br>

3. As we step through set of vertices X, we check if there are any “bad edges” that intersect edges which will connect G1 and G2 - we find and remove these while stepping through set X. If any edges form a smaller angle than the base edge and L, i.e. if any circumcircles that contain other vertices in G1 are formed while stepping through X, we will remove the edge from the base edge on the G1 side to that point in X. Since we know L will be connected to G2 at some point, we have to remove edges from the base edge from the G1 side to points with lower degree relative to the base edge than L as these edges will cross over the newly formed G1-G2 edge from L.</br>
4. Steps 2 and 3 will be repeated on G2 to find candidate vertex R.</br>
<img src="./example/4.png" width="500" height="500">
<img src="./example/5.png" width="500" height="500">
<img src="./example/6.png" width="500" height="500">
</br>
5. Then, we create a circumcircle with vertices on the base edge, and L. If this circumcircle does not contain R, we connect L to the base edge from it's side, since a circumcircle with no points inside defines a delaunay triangle. We also know no points from G2 are within this circumcircle, since R was the closest potential point. If the circumcircle does contain R, we know that R must be connected to the base edge since 4 points guarantee an existence of a Delaunay triangle, and since Delaunay triangles are unique unless all 4 points form a circle, only 1 candidate will create a triangle with the base edge. This is shown by drawing a circumcircle with the vertices on the base edge, and R, which will not contain L, and thus is a valid Delaunay triangle. Choosing to form a circumcircle with L is completely arbitrary and forming a circle with R would perform the same task without loss of generality.</br>
<img src="./example/7.png" width="500" height="500">
<img src="./example/8.png" width="500" height="500">
<img src="./example/9.png" width="500" height="500">
</br>
6. Find a new candidate on either G1 or G2 depending on which vertex was triangulated, and repeat step 5 with newly vertices on newly formed edge and L and R candidates (only one of which will be new). Here, our base edge will be replaced by two vertices on the newly formed edge between G1 and G2 which will become our new base edge, and the process can be repeated again - removing any bad edges found and finding the next valid edge between G1 and G2.</br>
<img src="./example/10.png" width="500" height="500">
</br>
7. Repeat no more candidates can be found.</br></br>

<img src="./example/12.png" width="500" height="500">
</br>
This merge process will be repeated until all subgraphs have been merged into the final Delaunay triangulation</br>
The recurrence equation for this algorithm is therefore:</br>
T(n) = 2O(n/2) + n</br>
Which, by master equation, produces a time complexity of O(nlogn)

</p>


<h4>Applications</h4>
<p>
Delaunay, and more specifically it’s dual the Voronoi diagram, can be used in the real world to find closest regions to a specific point.
This algorithm has found many uses in the real world, including hospital placement, aviation industry, and other infrastructure where finding the closest point to a region is very important. Some say the first use of Voronoi dates back to 1854, when a British doctor John Snow gathered data on individuals sick with cholera and after plotting data on a chart, realized that all fatalities were closest to a specific water source - which was found to be contaminated with the disease. [Irish Times]
</p>

</body>
<script type="module">
  import {Runtime, Inspector} from "https://cdn.jsdelivr.net/npm/@observablehq/runtime@4/dist/runtime.js";
  import define from "https://api.observablehq.com/@d3/hover-voronoi.js?v=3";
  const inspect = Inspector.into("#observablehq-96a9ef30");
  (new Runtime).module(define, name => (name === "canvas") && inspect());
</script>
